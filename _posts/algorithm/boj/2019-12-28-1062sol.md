---
title:  "Boj - 1062 가르침 풀이 "
excerpt: "Problem Solving - Brute Force"
header:
  teaser: /assets/img/algorithm/boj/boj_cover.png

categories:
  - Boj
  - Brute Force
tags:
  - Boj
  - Algorithm
  - 백준
  - baekjoon
---
## 1062 가르침 (작성중)

- N개의 단어가 주어졌을 때, K개의 글자로만 이루어진 단어의 개수를 고르는 문제.
- 모든 단어는 __anta__ 로 시작하고, __tica__ 로 끝난다.
- N <= 50, 단어의 길이 <= 15


> 경우의 수 계산해보기.
   - 26개의 알파벳 중에서 K 개를 고른다.
   - 각 알파벳을 선택한다 / 선택하지 않는다로 나누면 총 2^26 가지 경우의 수.
   - 2^20 = 약 100만, 2^6 = 64. 따라서 경우의 수는 약 6400만.
   - 여기에 단어의 수는 총 N개, 각 단어의 길이는 최대 15이므로,
   - 6400만 * N * 15 = 매우 큰 경우의 수.

<center>
<img src = "https://hyunjae-lee.github.io/assets/img/algorithm/ps/1062.jpg" width = "100%">
</center>

> 아이디어는 다음과 같다.
   - 모든 단어는 __anta__ 로 시작하고, __tica__ 로 끝나는 특성에서
   - `a`, `c`, `i`, `t`, `n` 은 항상 읽을 수 있어야 한다.
   - (그렇지 않으면, 모든 단어를 읽을 수 없다)
   - 즉, __26__ 개의 알파벳에서 __5__ 개를 제외한 __21__ 개의 알파벳이 되고,
   - __K__ 개를 고르는 것에서 __K - 5__ 개를 고르므로 경우의 수가 매우 줄어든다.


> 위 아이디어를 구현한 첫번째 솔루션.

```cpp
  // problem url : https://www.acmicpc.net/problem/1062
#include <iostream>
#include <vector>
#include <string>
using namespace std;
bool learn[26];

/*
    count(words)는 O(단어의 개수 * 단어의 길이)만큼의 시간복잡도가 요구된다.
    각각의 단어가 배운 알파벳으로만 이루어져 있는지 검사하는 것이 너무 오랜 시간이 걸린다.
    따라서 `시간 초과`가 발생한다.
*/
int count(vector<string> &words) {
    int cnt = 0;
    for (string word : words) {
        bool ok = true;
        for (char x : word) {
            if (!learn[x-'a']) {
                ok = false;
                break;
            }
        }
        if (ok) cnt += 1;
    }
    return cnt;
}

/*
0   1   2       23  24  25
a   b   c   ... x   y   z
o/x o/x o/x     o/x o/x o/x (사용한다/하지 않는다)

go(index = 알파벳의 번호, k = 몇 개의 알파벳을 더 배울 수 있는지, words = 단어)
*/

int go(int index, int k, vector<string> &words) {
    
    // 문제의 조건 : k개 까지 글자를 배울 수 있음.
    if (k < 0) return 0;

    // index 가 26이면 모든 알파벳을 사용할 수 있는 경우이다.
    if (index == 26) {
        return count(words);
    }
    int ans = 0;

    // learn = 알파벳 순 배열
    // ex) learn[0] = true 면, 알파벳 `a`를 배웠음.
    learn[index] = true;

    // 다음 알파벳을 배울 지 결정하기 위해 index + 1, index번째 글자를 배웠으니 k-1
    int t1 = go(index+1, k-1, words);

    // t1의 값이 정해졌다는 것은, index번째 알파벳을 배웠을 때의 정답을 의미한다. 
    // 따라서 index번째 알파벳을 배우지 않았을 때의 정답을 고려하기 위해 다시 false로 되돌린다.
    learn[index] = false;
    
    // 정답 비교
    if (ans < t1) ans = t1;

    // index번째의 알파벳이 a, n, t, i, c 가 아닌 경우,
    // 
    if (index != 'a'-'a' && index != 'n'-'a' && index != 't'-'a' && index != 'i'-'a' && index != 'c'-'a') {
        t1 = go(index+1, k, words);
        if (ans < t1) ans = t1;
    }
    return ans;
}
int main() {
    int n, m;
    cin >> n >> m;
    vector<string> words(n);
    for (int i=0; i<n; i++) {
        cin >> words[i];
    }
    cout << go(0, m, words) << '\n';
    return 0;
}

```

> 첫번째 솔루션의 시간 초과를 해결한 솔루션

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;
int count(int mask, vector<int> &words) {
    int cnt = 0;
    for (int word : words) {
        if ((word & ((1<<26)-1-mask)) == 0) {
            cnt += 1;
        }
    }
    return cnt;
}
int go(int index, int k, int mask, vector<int> &words) {
    if (k < 0) return 0;
    if (index == 26) {
        return count(mask, words);
    }
    int ans = 0;
    int t1 = go(index+1, k-1, mask | (1 << index), words);
    if (ans < t1) ans = t1;
    if (index != 'a'-'a' && index != 'n'-'a' && index != 't'-'a' && index != 'i'-'a' && index != 'c'-'a') {
        t1 = go(index+1, k, mask, words);
        if (ans < t1) ans = t1;
    }
    return ans;
}
int main() {
    int n, m;
    cin >> n >> m;
    vector<int> words(n);
    for (int i=0; i<n; i++) {
        string s;
        cin >> s;
        for (char x : s) {
            words[i] |= (1 << (x-'a'));
        }
    }
    cout << go(0, m, 0, words) << '\n';
    return 0;
}
```

- 완전 탐색의 또 다른 문제들과 그 구현법들을 확인해보려면 [완전 탐색 Tips](https://hyunjae-lee.github.io/problem%20solving/bruteforce/){: target="_blank" } 를 참고.